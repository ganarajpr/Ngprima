mixin FunctionDeclaration(node)
    .functiondeclaration(scope-creator='true')
        +fn(node)

mixin fn(node)
    .token.function function
    if node.id
        identifier(name=node.id.name)
    .token.punctuation (
    +params(node.params)
    .token.punctuation )
    .token.punctuation {
    br
    +Statement(node.body)
    .token.punctuation }
    br

mixin VariableDeclaration(node)
    .variabledeclaration
        .token.keyword #{node.kind}
        each decl,index in node.declarations
            +VariableDeclarator(decl)
            if index <= node.declarations.length - 1
                .token.punctuation ,

mixin VariableDeclarator(node)
    .variabledeclarator
        identifier(name=node.id.name)
        if node.init
            .token.punctuation =
            +expression(node.init)


mixin property(node)
    .property
        identifier(name=node.key.name)
        .token.punctuation :
        +expression(node.value)

mixin literal(node)
    .literal
        .token.value #{node.raw}

mixin ObjectExpression(node)
    .objectexpression
        .token.punctuation {
        each prop,index in node.properties
            +property(prop)
            if index < node.properties.length - 1
                .token.punctuation ,
        .token.punctuation }

mixin ArrayExpression(node)
    .arrayexpression
        .token.punctuation [
        each elem,index in node.elements
            +expression(elem)
            if index < node.elements.length - 1
                .token.punctuation ,
        .token.punctuation ]

mixin FunctionExpression(node)
    .functionexpression(scope-creator='true')
        +fn(node)

mixin ThisExpression(node)
    .thisexpression this

mixin MemberExpression(node)
    .memberexpression
        +expression(node.object)
        .token.punctuation .
        identifier(name=node.property.name)

mixin CallExpression(node)
    .callexpression
        +expression(node.callee)
        .token.punctuation (
        +arguments(node.arguments)
        .token.punctuation )

mixin AssignmentExpression(node)
    .AssignmentExpression
        +expression(node.left)
        .token.operator =
        +expression(node.right)


mixin BinaryExpression(node)
    .BinaryExpression
        +expression(node.left)
        .token.operator #{node.operator}
        +expression(node.right)


mixin expression(node)
    if node.type === 'MemberExpression'
        +MemberExpression(node)
    if node.type === 'ArrayExpression'
        +ArrayExpression(node)
    if node.type === 'ObjectExpression'
        +ObjectExpression(node)
    if node.type === 'ThisExpression'
        +ThisExpression(node)
    if node.type === 'AssignmentExpression'
        +AssignmentExpression(node)
    if node.type === 'FunctionExpression'
        +FunctionExpression(node)
    if node.type === 'CallExpression'
        +CallExpression(node)
    if node.type === 'BinaryExpression'
        +BinaryExpression(node)
    if node.type === 'Identifier'
        identifier(name=node.name)
    if node.type === 'Literal'
        +literal(node)


mixin ForStatement(node)
    .ForStatement
        .token.keyword for
        .token.punctuation (
        if node.init
            if node.init.type === 'VariableDeclaration'
                +VariableDeclaration(node.init)
            else
                +expression(node.init)
        .token.punctuation ;
        if node.test
            +expression(node.test)
        .token.punctuation ;
        if node.update
            +expression(node.update)
        .token.punctuation )
        .token.punctuation {
            +body(node.body)
        .token.punctuation }


mixin IfStatement(node)
    .IfStatement
        .token.keyword if
        .token.punctuation (
        +expression(node.test)
        .token.punctuation )
        .token.punctuation {
        +Statement(node.consequent)
        .token.punctuation }
        if node.alternate
            +Statement(node.alternate)

mixin body(node)
    each val,index in node
        +Statement(val)


mixin EmptyStatement(node)
    .EmptyStatement
    .token.punctuation ;

mixin BlockStatement(node)
    +body(node.body)


mixin Statement(node)
    if node.type === 'ExpressionStatement'
        +ExpressionStatement(node)
    if node.type === 'ForStatement'
        +ForStatement(node)
    if node.type === 'ForInStatement'
        +ForInStatement(node)
    if node.type === 'WhileStatement'
        +WhileStatement(node)
    if node.type === 'DoWhileStatement'
        +DoWhileStatement(node)
    if node.type === 'IfStatement'
        +IfStatement(node)
    if node.type === 'BreakStatement'
        +BreakStatement(node)
    if node.type === 'ContinueStatement'
        +ContinueStatement(node)
    if node.type === 'VariableDeclaration'
        +VariableDeclaration(node)
    if node.type === 'FunctionDeclaration'
        +FunctionDeclaration(node)
    if node.type === 'SwitchStatement'
        +SwitchStatement(node)
    if node.type === 'ThrowStatement'
        +ThrowStatement(node)
    if node.type === 'ReturnStatement'
        +ReturnStatement(node)
    if node.type === 'DebuggerStatement'
        +DebuggerStatement(node)
    if node.type === 'WithStatement'
        +WithStatement(node)
    if node.type === 'LabeledStatement'
        +LabeledStatement(node)
    if node.type === 'TryStatement'
        +TryStatement(node)



mixin WhileStatement(node)
    .WhileStatement
        .token.keyword while
        .token.punctuation (
        +expression(node.test)
        .token.punctuation )
        .token.punctuation {
        +Statement(node.body)
        .token.punctuation }

mixin DoWhileStatement(node)
    .DoWhileStatement
        .token.keyword do
        .token.punctuation {
        +Statement(node.body)
        .token.punctuation }
        .token.keyword while
        .token.punctuation (
        +expression(node.test)
        .token.punctuation )



mixin ForInStatement(node)
    .ForInStatement
        .token.keyword for
        if node.each
            .token.keyword each
        .token.punctuation (
        if node.left === 'VariableDeclaration'
            +VariableDeclaration(node.left)
        else
            +expression(node.left)
        .token.keyword in
        +expression(node.right)
        .token.punctuation )
        .token.punctuation {
        +Statement(node.body)
        .token.punctuation }


mixin TryStatement(node)
    .token.keyword try
    .token.punctuation {
    +BlockStatement(node.block)
    .token.punctuation }
    each guard,index in node.handlers
        +CatchClause(guard)
    if node.finalizer
        +BlockStatement(node.finalizer)

mixin CatchClause(node)
    .token.keyword catch
    .token.punctuation (
    identifier(name=node.param.name)
    .token.punctuation )
    .token.punctuation {
    +BlockStatement(node.body)
    .token.punctuation }

mixin BreakStatement(node)
    .BreakStatement
    .token.keyword break
    if node.label
        identifier(name=node.label.name)
    .token.punctuation ;

mixin ContinueStatement(node)
    .ContinueStatement
    .token.keyword continue
    if node.label
        identifier(name=node.label.name)
    .token.punctuation ;


mixin ReturnStatement(node)
    .ReturnStatement
    .token.keyword return
    if node.argument
        +expression(node.argument)
    .token.punctuation ;

mixin WithStatement(node)
    .WithStatement
    .token.keyword with
    .token.punctuation (
    +expression(node.object)
    .token.punctuation )
    .token.punctuation {
    +Statement(node.body)
    .token.punctuation }


mixin LabeledStatement(node)
    .LabeledStatement
    identifier(name=node.label.name)
    .token.punctuation :
    +Statement(node.body)


mixin DebuggerStatement(node)
    .DebuggerStatement
    .token.keyword debugger
    .token.punctuation ;

mixin ThrowStatement(node)
    .ThrowStatement
    .token.keyword throw
    +expression(node.argument)


mixin SwitchCases(node)
    .token.keyword case
    if node.test
        +expression(node.test)
    .token.punctuation :
    +body(node.consequent)

mixin SwitchStatement(node)
    .SwitchStatement
    .token.keyword switch
    .token.punctuation (
    +expression(node.discriminant)
    .token.punctuation )
    .token.punctuation {
    each case,index in node.cases
        +SwitchCases(case)
    .token.punctuation }


mixin program(node)
    .program(scope-creator='true')
        +body(node)

mixin arguments(args)
    each val,index in args
        +expression(val)
        if index < args.length - 1
            .token.punctuation ,

mixin params(params)
    each val,index in params
        identifier(name=val.name)
        if index < params.length - 1
            .token.punctuation ,

mixin ExpressionStatement(node)
    .expressionstatement
        +expression(node.expression)


+program(body)